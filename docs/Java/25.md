---
layout: default
title: 자동화
date: 2025-01-18
parent: Server
nav_order: 25
---

created at 2025-01-18
{: .label .label-yellow }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}


### 1. Slack List Notification

뭔가 git action 을 사용하다보면 중간 단계들을 slack 으로 알림을 받아야할 때가 많음. 메세지 전송 스크립트가 너무 귀찮아서 공통 모듈로 만들어서 쓰는데 이마저도 가져와서 chmod +x 실행권한 추가해야해서 귀찮음.
 
그래서 그냥 git actions marketplace 에 올려놓고 가져와서 편하게 아래와 같이 쓸 수 있도록 수정. ~~다만 수정이 조금 귀찮을 수 있음.~~ 이건 정말 공통적으로 사용하는 스크립트만 마켓에 올리는 것이 좋을 것 같음. 

```yaml
  - name: Send Message to Slack with Building Modules
    uses: ghkdqhrbals/slack-list@v1.0.12
    with:
      slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
      actor: ${{ github.actor }}
      messages: '${{ steps.set-modules.outputs.json-array }}' # json string list syntax
      message-title: '개발 수동 배포 시작 (Version: ${{ steps.set-version.outputs.version }})'
      color: '#3bb143'
```

드래프트 repo : [https://github.com/ghkdqhrbals/slack-list](https://github.com/ghkdqhrbals/slack-list)
> git repo root 에 actions.yaml 만들어서 draft 생성 후 release 한 뒤 use 로 해당 액션 가져와서 사용할 수 있음.

그러면 아래와 같이 결과도착함.

![img_2.png](../img_2.png)


### 2. Slack Message Update

**너무 많은 메세지가 쌓이면서 메세지를 뭉쳐야할 필요가 생김.** 그래서 기존 글을 업데이트하거나 댓글에 부가정보를 달아야할 때가 있음. 이럴 때 사용할 수 있는 스크립트를 만들어봄.

![img_3.png](../img_3.png)

```bash
#!/bin/bash

# 매개변수 확인
if [ $# -lt 3 ]; then
  echo "Usage: $0 [-u] <token> <new_message> <channel>"
  exit 1
fi

# 옵션 파싱
silent_mode=false
if [ "$1" == "-u" ]; then
  silent_mode=true
  shift
fi

# 매개변수 읽기
token="$1"                      # Slack App 토큰 (xoxb- 또는 xoxp-로 시작)
new_message="$2"                # 새 메시지
channel="$3"                    # 채널 ID 또는 채널 이름
timestamp_file=".slack_last_ts" # 로컬 timestamp 저장 파일

# Slack 메시지 업데이트 함수 (attachments 대체)
update_message_with_attachments() {
  local ts="$1"
  local msg="$2"

  # 새로운 attachment 생성
  new_attachments="[
    {
      \"color\": \"#3bb143\",
      \"text\": \"$msg\"
    }
  ]"

  # 메시지 업데이트 요청
  curl -s -X POST -H "Authorization: Bearer $token" -H 'Content-type: application/json' \
    --data "{
      \"channel\": \"$channel\",
      \"ts\": \"$ts\",
      \"attachments\": $new_attachments
    }" \
    https://slack.com/api/chat.update | jq .
}

# 댓글로 메시지 추가 함수
add_comment() {
  local ts="$1"
  local msg="$2"

  # 댓글 추가 요청
  response=$(curl -s -X POST -H "Authorization: Bearer $token" -H 'Content-type: application/json' \
    --data "{
      \"channel\": \"$channel\",
      \"text\": \"$msg\",
      \"thread_ts\": \"$ts\"
    }" \
    https://slack.com/api/chat.postMessage)

  # 응답 디버깅
  echo "$response" | jq .
}

# 새 메시지 전송 함수
send_message() {
  local msg="$1"
  response=$(curl -s -X POST -H "Authorization: Bearer $token" -H 'Content-type: application/json' \
    --data "{
      \"channel\": \"$channel\",
      \"text\": \"$msg\"
    }" \
    https://slack.com/api/chat.postMessage)

  # 메시지 전송 후 timestamp 추출
  local ts
  ts=$(echo "$response" | jq -r '.ts')
  if [[ "$ts" != "null" ]]; then
    echo "$ts" > "$timestamp_file"
    echo "Message sent with ts: $ts"
  else
    echo "Failed to send message. Response: $response"
  fi
}

if [ -f "$timestamp_file" ]; then
  ts=$(cat "$timestamp_file")
  echo "Found existing timestamp: $ts"

  if [ -z "$ts" ]; then
    echo "Timestamp is empty. Sending new message..."
    send_message "$new_message"
  else
    if $silent_mode; then
      echo "Replacing attachments for ts: $ts"
      update_message_with_attachments "$ts" "$new_message"
    else
      echo "Adding comment to existing message with ts: $ts"
      add_comment "$ts" "$new_message"
    fi
  fi
else
  echo "timestamp file not found. Sending new message..."
  send_message "$new_message"
fi
```

### 3. K8S 롤아웃 트래킹

쿠버네티스 deploy 는 완료했는데 롤아웃이 정상적으로 완료되었는지 확인해야할 때가 있음. deployment 는 배포했지만 실제로 image 를 pulling 못하고 있다거나 pod 의 readinessGate 가 정상적으로 작동하지 않는 경우가 있음. 이럴 때 사용할 수 있는 스크립트를 만들어봄.

사전에 matrix 로 배포할 모듈들을 설정하고 아래의 rollout 상태체크 스탭을 넣음.

```bash
  - name: Check Rollout Status
    run: |
      rollout_data='${{ steps.deploy_step.outputs.rollout-data }}'
      echo "Rollout data: $rollout_data"
      
      chmod +x ./scripts/send_slack_message.sh
      
      echo "$rollout_data" | tr -d '[]' | tr '}' '\n' | sed '/^$/d' | while read -r deployment_info; do
        deployment_info=$(echo "$deployment_info" | sed -e 's/,$//' -e 's/^,//' -e 's/$/}/')
      
        MODULE=$(echo "$deployment_info" | grep -o '"module":"[^"]*"' | cut -d':' -f2 | tr -d '"')
        DEPLOYMENT_NAME=$(echo "$deployment_info" | grep -o '"deployment":"[^"]*"' | cut -d':' -f2 | tr -d '"')
        FRANCHISE=$(echo "$deployment_info" | grep -o '"franchise":"[^"]*"' | cut -d':' -f2 | tr -d '"')
      
        # 추출한 데이터 확인
        echo "Module: $MODULE"
        echo "Deployment Name: $DEPLOYMENT_NAME"
        echo "Franchise: $FRANCHISE"
      
        # 백그라운드에서 실행
        {
          echo "Checking rollout status for $MODULE ($DEPLOYMENT_NAME in $FRANCHISE namespace)"
          OUTPUT=$(/usr/local/bin/kubectl rollout status deployment/$DEPLOYMENT_NAME -n $FRANCHISE --timeout=10m 2>&1)
          STATUS=$?
      
          if [[ $STATUS -ne 0 ]]; then
          echo "Rollout failed for deployment: $DEPLOYMENT_NAME"
             ./scripts/send_slack_message.sh "${{ env.SLACK_WEBHOOK_URL }}" \
               "[DEV] $MODULE 롤아웃 실패" \
               "${{ env.SLACK_CHANNEL }}" \
               "Deployment Bot" \
               ":rocket:"
          else
             echo "Rollout succeeded for deployment: $DEPLOYMENT_NAME"
             ./scripts/send_slack_message.sh "${{ env.SLACK_WEBHOOK_URL }}" \
               "[DEV] $MODULE 롤아웃 완료" \
               "${{ env.SLACK_CHANNEL }}" \
               "Deployment Bot" \
               ":rocket:"
          fi
        } & pids+=($!)
      done
      
      echo "백그라운드 프로세스 ID : ${pids[@]}"
      wait "${pids[@]}"
      
      echo "모든 롤아웃 완료"
```

> env 세팅값들은 secrets 로 관리 설정하는게 좋음. 또한 현재 여러 변수들을 동적으로 읽고있는데 robust 하다고 볼 순 없음. 너무 동적으로 텍스트를 파싱하고 있어서 파싱에러가 발생할 수 있기 때문. 

위의 3가지 + a가 자동화되서 아래와 같은 결과를 알림으로 받을 수 있음.



### Appendix

* [shell script multiple background process waiting](https://stackoverflow.com/questions/40377623/bash-wait-command-waiting-for-more-than-1-pid-to-finish-execution)
> bash 특정버전 이후 부터는 wait 명령어로 여러개의 백그라운드 프로세스를 기다릴 수 있음. 이전 버전에서는 wait 명령어가 하나의 pid 만을 기다렸음.

* bash 의 while 은 서브쉘 실행해서 다른 프로세스임. 그래서 메모리를 카피해서 일단 가져오지만(copy-on-write) 부모쉘 메모리에 저장된 변수에 값을 변경하거나 추가할 수 없고 카피된 값을 읽을수만 있음. 그래서 for loop 로 돌려야함