---
layout: default
title: Netty 아키텍처 (작성중)
parent: Java-Spring
nav_order: 8
---
# Netty 란?
Netty framework provides non-blocking easy-to-use I/O APIs for the JVM, it enables quick and easy development of network applications.

Netty threading model is depicted below, it’s slightly different from reactor Master-slave Reactor model. For now, just keep it in mind, we will try to investigate the accountability of each core component.

Netty ByteBuf
ByteBuffer usage is overly complex and somewhat cumbersome to use, Netty’s alternative to ByteBuffer is ByteBuf, a powerful implementation that addresses the limitations of the JDK API and provides a better API for network application developers.
Netty zero copy
OS-level zero copy involves avoiding copying memory blocks from one location to another (typically from user land to kernel land) before sending data to the hardware driver (network card or disk drive) or vice versa.
Netty zero copy is referred to optimising data manipulation on Java level (user-space only).
Netty ByteBuf allows to read contents of multiple byte buffers without actually copying their content on the heap, but this mean that we should release the memory by ourself as the garbage collector is not effective (Direct buffers).
Besides heap and direct buffer, Netty uses transferTo() method for file transfer to directly send data in the socket buffer and thus avoiding extra buffer copy.
Further reading: https://developer.ibm.com/articles/j-zerocopy/
Netty Channel
Channel is a component providing users a ways to process I/O operations, such as read and write.
A ChannelPipeline encapsulates a series of ChannelHandler instances as two-way linked list. Inbound and outbound events that flow through a channel can be intercepted by the ChannelPipeline. Whenever a channel is created, a ChannelPipeline is created and permanently bound to the channel. Triggered events can be intercepted, passed, ignored or terminated by ChannelHandler. The head of the linked list is HeadContext, and the tail of the linked list is TailContext.
Netty Channel lifecycle
There are four Channel lifecycle states described below:
ChannelUnregistered: The Channel was created, but isn’t registered to an EventLoop.
ChannelRegistered: The Channel is associated to an EventLoop.
ChannelActive: The Channel is active, connected to remote peer.
ChannelInactive: The Channel isn’t connected to the remote peer.
Multiple channels can be registered to an event loop, in fact, each event loop has its own selector and as dicussed in previous sections, a selector can handle multiple channels.
Netty ChannelHandlerContext
Enables a ChannelHandler to interact with its ChannelPipeline and other handlers. Among other things a handler can notify the next ChannelHandler in the ChannelHandler well as modify the ChannelPipeline it belongs to dynamically.
Netty ChannelInitializer
A special ChannelInboundHandler which offers an easy way to initialize a Channel once it was registered to its EventLoop. Its method initiChannel is called whenever a new incoming TCP connection is accepted by the TCP server.
Typically the ChannelInitializer is called to register a SocketChannel and removes itself from the ChannelPipeline.
Netty ChannelHandlers
ChannelHandlers Handles or intercepts events and forwards it to the next handler in a ChannelPipeline. Based on its origin, an event is handled by the ChannelInboundHandler or ChannelOutboundHandler, and the ChannelHandlerContext forwards the event to the next ChannelHandler.
ChannelInboundHandler handles and intercepts inbound operations.
ChannelInboundHandler handles and intercepts outbound operations.
An inbound event is transmitted from the head of the linked list to the last inbound handler, whereas an outbound event is transmitted from the tail of the linked list to the first outbound handlers.
Netty ChannelFuture and ChannelPromise
In Netty, all I/O operations are asynchronous, most of the methods in Channel- OutboundHandler take a ChannelPromise argument to be notified when the operation completes. ChannelPromise is a subinterface of ChannelFuture that defines the writable methods, such as setSuccess() or setFailure(), thus making ChannelFuture immutable.
The above figure depict what we have discussed:

Netty Bootstrap
As discussed earlier, using a selector we can monitor multiple resources and when an event is ready, we delegates to appropriate handlers and continue the monitoring again, this is referred as an event loop.
Netty’s NioEventLoop is handling not only IO events, that is, data ready for consumption, but it constantly monitor a task queue that comprises two kinds of tasks:
Common tasks.
Tasks scheduled for later execution.
The idea is to encapsulates operations into a Task (such as firing events through the channel pipeline) and puts it into the taskQueue to maintain serialization.
📝 To keep in mind: NioEventLoop=Selector+ 1 thread+1 taskQueue, thus we can think of EventLoop as a subReactor.
Netty NioEventLoopGroup
NioEventLoopGroup contains multiple NioEventLoops and manages their lifecycles. Each NioEventLoop contains an NIO selector, a queue, and a thread. The thread is used to poll the read and write events of the channels registered to the selector and handle the events that are delivered to the queue.
Netty BossGroup and WorkerGroup
BossEventLoopGroup is an EventLoopGroup responsible for receiving client connections and handing SocketChannel to WorkerEventLoopGroup (a second EventLoopGroup) for I/O operations.
A Boss NioEventLoop thread performs the following steps:
Handle accept events, establish a connection with the client, and generate a NioSocketChannel.
Register the NioSocketChannel with the selector on a child NIOEventLoop.
Perform runAllTasks to handle tasks in a task queue.
A worker NioEventLoop thread performs the following steps:
Poll the read and write events of all NioSocketChannel channels registered to the selector.
Handle the read and write operations (after connection has been established).
Perform runAllTasks to handle tasks in the task queue.


# 1. Thread Group

Reactor 패턴의 이벤트 형식 소켓 IO 핸들러를 컨트롤하는 프레임워크입니다.

Netty abstracts the **BossGroup** and **WorkerGroup** thread pools of the NioEventLoopGroup class. BossGroup receives connection requests from clients, whereas WorkerGroup handles connections that complete TCP three-way handshakes.

NioEventLoopGroup contains multiple NioEventLoops and manages their lifecycles. Each NioEventLoop contains an NIO selector, a queue, and a thread. The thread is used to poll the read and write events of the channels registered to the selector and handle the events that are delivered to the queue.

A Boss NioEventLoop thread performs the following steps:

1) Handle accept events, establish a connection with the client, and generate a NioSocketChannel.
2) Register the NioSocketChannel with the selector on a worker NIOEventLoop.
3) Perform runAllTasks to handle tasks in the task queue.

A worker NioEventLoop thread performs the following steps:

1) Poll the read and write events of all NioSocketChannel channels registered to the selector.
2) Handle the read and write events and businesses in corresponding NioSocketChannels.
3) Perform runAllTasks to handle tasks in the task queue. Some time-consuming businesses can be handled in the task queue, which does not affect the data flow in the pipeline.

Worker NIOEventLoop threads handle NioSocketChannel businesses in the pipeline. In the pipeline, the handler linked list is maintained to handle data in the channels.

# 2. ChannelPipeline

Netty abstracts the data pipelines of channels into ChannelPipelines, allowing messages to be transmitted in ChannelPiplines. A ChannelPipeline contains the two-way linked list of ChannelHandlers, which intercept I/O events. It allows you to add and delete ChannelHandlers to customize different business logic without modifying existing ChannelHandlers. This supports modification closure and extensions.

A ChannelPipeline is a series of ChannelHandler instances. Inbound and outbound events that flow through a channel can be intercepted by the ChannelPipeline. Whenever a channel is created, a ChannelPipeline is created and permanently bound to the channel. This channel cannot be attached to another ChannelPipeline or separated from the current one. Netty takes charge of all these operations, without the need for special intervention by developers.

Based on its origin, an event is handled by the ChannelInboundHandler or ChannelOutboundHandler, and the ChannelHandlerContext forwards the event to the next ChannelHandler. A ChannelHandler can instruct the next ChannelHandler in the ChannelPipeline to handle the event. Read events (inbound events) and write events (outbound events) use the same pipeline. An inbound event is transmitted from the head of the linked list to the last inbound handler, whereas an outbound event is transmitted from the tail of the linked list to the first outbound handlers. They do not interfere with each other.