---
layout: default
title: 24. DB connection 을 위한 DB-ThreadPool 반환 및 성능 향상
parent: 실시간 채팅서버 프로젝트
nav_order: 24
---

#### INDEX
0. 성능개선결과부터!
1. 어떻게? 어디에서 성능개선을 하였을까요?

# 0. 성능개선결과부터! (feat. [gotybench](https://github.com/ghkdqhrbals/gotybench))

![img](../../../assets/img/performance/1.png)

중간중간에 DB connection이 반환되지 않아서 대기하던 곳 또한 전체적으로 완화되었습니다!

이에 따라서 평균/최대/최소 응답시간이 아래와 같이 전체적으로 개선되었어요.

* 평균 응답시간 개선 : 1.1초 -> **0.9초**
* 최대 응답시간 개선 : 5.4초 -> **3.9초**
* 최소 응답시간 개선 : 0.027초 -> **0.02초**

# 1. 어떻게? 어디에서 성능개선을 하였을까요?
저는 다음과 같이 서비스와 데이터베이스에 별도의 스레드 풀을 할당해서 사용하는데요.

해당 과정에서 데이터베이스 쿼리 스레드가 나머지 서비스를 계속 타게 되었습니다.

**당연히 데이터베이스의 connection 을 물고있는 쿼리 스레드가 나머지 서비스를 실행하지 않고 빠르게 반환되어야겠죠?**

그래서 아래와 같이 서비스에서 리포지토리를 호출 한 뒤, thenAcceptAsync를 통해 리포지토리의 스레드를 반환하도록 설정하였습니다.

```java
@Slf4j
@Repository
public class UserRepositoryJDBC {
   public CompletableFuture<?> saveAll(List<User> users) {
      return CompletableFuture.runAsync(() -> {
         String sql = "INSERT INTO user_table (user_id, email, join_date, login_date, logout_date, user_name, user_pw) " +
                 "VALUES (?, ?, ?, ?, ?, ?, ?) ";
         jdbcTemplate.batchUpdate(sql,
                 users,
                 batchSize,
                 (PreparedStatement ps, User user) -> {
                    ps.setString(1, user.getUserId());
                    ps.setString(2, user.getEmail());
                    ps.setObject(3, user.getJoinDate());
                    ps.setObject(4, user.getLoginDate());
                    ps.setObject(5, user.getLogoutDate());
                    ps.setString(6, user.getUserName());
                    ps.setString(7, user.getUserPw());
                 });
      }, databaseExecutor).exceptionally(e -> {
         log.info(e.getMessage());
         if (e.getCause().getClass() == DuplicateKeyException.class) {
            throw new CustomException(DUPLICATE_RESOURCE);
         }
         throw new RuntimeException();
      });
   }
}

@Slf4j
@Service
@Transactional
public class UserServiceImpl extends KafkaTopicConst implements UserService {
   ...
   @Override
   public CompletableFuture<?> save(User user) throws CustomException {
      DeferredResult<ResponseEntity<?>> dr = new DeferredResult<>();
      return CompletableFuture.supplyAsync(()->{
         return Arrays.asList(user);
      }, serviceExecutor).thenAccept(u -> {
         try {
            userRepositoryJDBC.saveAll(u).get(); // 당연히 쿼리 스레드는 Blocking!
         } catch (InterruptedException e) {
            throw new RuntimeException(e);
         } catch (ExecutionException e) {
            throw new RuntimeException(e);
         }
      }).exceptionally(e -> {
         log.info("서비스 에러");
         if (e.getCause() instanceof CustomException){
            CustomException ex = (CustomException) e.getCause(); // 에러 unwrapping
            throw ex;
         } else{
            throw new RuntimeException(); // default 에러 송출
         }
      });
   }
   ...
}

@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class UserController extends KafkaTopicConst {
   ...
   @PostMapping("/user")
   public DeferredResult<ResponseEntity<?>> addUser(@RequestBody RequestAddUserDTO request) throws InterruptedException {
      DeferredResult<ResponseEntity<?>> dr = new DeferredResult<>();

      User user = new User(
              request.getUserId(),
              request.getUserPw(),
              request.getEmail(),
              request.getUserName(),
              LocalDate.now(),
              LocalDate.now(),
              LocalDate.now()
      );

      // 유저 서비스를 통해 유저 저장
      saveUserHandler(dr, user);
      return dr;
   }

   private void saveUserHandler(DeferredResult<ResponseEntity<?>> dr, User user) {
      CompletableFuture
              .runAsync(() -> {
              }).thenCompose(s -> {
                 return userService.save(user);
              }).thenAcceptAsync(s1 -> { // 이 부분에서 thenAccept -> thenAcceptAsync을 통해 데이터베이스에 할당한 스레드 풀을 반환시킵니다.
                 sendToKafkaWithKey(TOPIC_USER_CHANGE, new RequestUserChange(user.getUserId(), user.getUserName(), "", "INSERT"), user.getUserId());
                 dr.setResult(ResponseEntity.ok("success"));
              }).exceptionally(e -> {
                 if (e.getCause() instanceof CustomException) {
                    dr.setResult(ErrorResponse.toResponseEntity(((CustomException) e.getCause()).getErrorCode())); // 에러 클라이언트에게 전달
                 } else {
                    dr.setResult(ResponseEntity.badRequest().body("default bad request response")); // default 에러
                 }
                 return null;
              });
   }
   ...
}
```
