---
layout: default
title: 40. 서버 성능개선 기록 - 1 (작성중)
parent: 📌 실시간 채팅서버 프로젝트
nav_order: 40
---

created at 2023-12-13
{: .label .label-yellow }

# ngrinder 를 통한 로그인 성능 테스트

### https://www.litcodev.com/api/login
* 로그인

![img](../../../assets/performance/chatloginUser99.png)
![img](../../../assets/performance/chatloginUser990.png)

### https://foxee.co.kr/api/login
* 로그인

![img](../../../assets/performance/foxeeloginUser2500.png)

### https://www.litcodev.com/api-chat/friends
* 로그인 후 친구목록 조회
* Groovy Script

![image](https://github.com/ghkdqhrbals/spring-chatting-server/assets/29156882/25b8b613-616f-44f8-8fd4-44cb1d2ace90)

![image](https://github.com/ghkdqhrbals/spring-chatting-server/assets/29156882/c0cfc2c3-d0f0-45a1-85b0-a2f9f3e11cc9)

```groovy
@RunWith(GrinderRunner)
class TestRunner {

	public static GTest test
	public static HTTPRequest request
	public static Map<String, String> headers = [:]
	public static String loginBody = "{\n    \"username\":\"your_id\",\n    \"password\":\"your_password\"\n}"
	public static List<Cookie> cookies = []

	@BeforeProcess
	public static void beforeProcess() {
		HTTPRequestControl.setConnectionTimeout(300000)
		test = new GTest(1, "www.litcodev.com")
		request = new HTTPRequest()

		// Set header data
		headers.put("Content-Type", "application/json")
		grinder.logger.info("before process.")

		// 로그인 요청
		HTTPResponse loginResponse = request.POST("https://www.litcodev.com/api/login", loginBody.getBytes())
		if (loginResponse.statusCode == 200) {
			cookies=CookieManager.getCookies()
			grinder.logger.info("cookies: {}", cookies)
		} else {
			grinder.logger.error("Login failed with status code: {}", loginResponse.statusCode)
		}
	}

	@BeforeThread
	public void beforeThread() {
		test.record(this, "test")
		grinder.statistics.delayReports = true
		grinder.logger.info("before thread.")
	}

	@Before
	public void before() {
		request.setHeaders(headers)
		CookieManager.addCookies(cookies)
		grinder.logger.info("before. init headers and cookies")
	}

	@Test
	public void test() {
		HTTPResponse chatResponse = request.GET("https://www.litcodev.com/api-chat/friends")
		if (chatResponse.statusCode == 301 || chatResponse.statusCode == 302) {
			grinder.logger.warn("Warning. The response may not be correct. The response code was {}.", chatResponse.statusCode)
		} else {
			assertThat(chatResponse.statusCode, is(200))
		}
	}
}
```

[문제점-1] 과도한 부하분산 테스트 시, EKS 노드 클러스터 내 노드가 아예 죽어버리는 경우
{: .text-red-200}
로그인 기능을 수행하는 API 인 `POST /api/login` 에 1000명의 동시 사용자 요청을 nGrinder를 통해 부하분산 테스트를 진행하였더니, cpu 사용률이 100% 에 도달하면서 워커노드가 죽어버렸습니다.

[해결방법-1] cpu limit 설정
{: .text-green-200}

첫 번째 방법으로는 각 파드 별로 resource limit 을 설정해주는 것입니다. 이렇게 되면 하나의 파드가 사용할 수 있는 최대 cpu 나 memory 의 리소스 limit 을 초과하게 되면, OOKill 을 강제로 발생시킵니다. 
그래서 노드의 resource usage 를 100% 찍는걸 막을 수 있게 되겠죠?

일단 이 방법을 적용하기 위해서는 알맞는 limit 을 적어주어야합니다. 그래서 먼저 각 파드의 cpu 사용량을 확인해보았습니다.

<img width="1476" alt="image" src="https://github.com/ghkdqhrbals/spring-chatting-server/assets/29156882/af15bb3b-522d-45fa-bed8-baa08babad0c">

`VUSER=100` 일 때 chatting 서버의 vcpu 코어 사용량은  1.21 까지 증가하는 것을 확인하였습니다. 그리고 `VUSER=1000` 일 땐 1.80 까지 증가하는것을 확인했습니다. 
만약 chatting 서버의 cpu limit 을 1.7로 설정해준다면, 동시접속자 수 초과일 때 노드자체가 죽는 것을 방지할 수 있겠죠? 

하지만 이렇게 되면 노드는 안죽을 지 모르지만 서비스 자체가 죽는 경우가 발생합니다. 그래서 두 번째 방법으로는 HPA 를 통해 파드의 개수를 늘려주는 것입니다.

[해결방법-2] HPA 설정

```yaml

몇 가지 생각해본 결과, cpu limit 설정을 통해 cpu 사용률을 제한할 수 있을 것 같았습니다. 아래와 같이 cpu limit 을 설정해보았습니다.

```yaml
resources:
  limits:
    cpu: 1000m
```


