---
layout: default
title: 37. Spring Cloud 기반 MSA 변환 시작-9(FE/BE 동기화)
parent: 📌 실시간 채팅서버 프로젝트
nav_order: 37
---

# 1. FE/BE 동기화
## 1.1 FE 페이지 수정

* 인증서버에 유저 API 요청을 전달했을 떄, 인증서버와 채팅서버, 고객서버의 상태를 SSE로 받아옵니다.
* 사용기술 스택
  * STOMP
  * SSE
  * Spring-Webflux
* 오렌지 : 대기중, 초록 : 성공, 빨강 : 실패(중복발견)

**중복없는 유저 생성 시, Success**

![img](../../../assets/img/alg/1.png){: width="50%" height="50%" align='left'}
![img](../../../assets/img/alg/2.png){: width="50%" height="50%" align='right'}

**중복인 유저 생성 시, Fail**(어느 서비스에서 중복이 발생하면 해당 서비스만 빨간불)

![img](../../../assets/img/alg/3.png){: width="50%" height="50%" align='left'}
![img](../../../assets/img/alg/4.png){: width="50%" height="50%" align='right'}

Youtube : [https://www.youtube.com/watch?v=0g_3M711bwI](https://www.youtube.com/watch?v=0g_3M711bwI)

### 1.2 FE 비동기 처리 수정
* 메인 스레드는 Flux 스레드로부터 onComplete()을 수신받을 때 까지 대기해야합니다. 그래서 **synchronize**의 `notify`, `wait`를 통해 mutex lock 을 사용하였습니다. 결과로 메인 스레드는 block 되어 BackEnd에서 SSE를 모두 수신받을 때 까지 대기합니다.

```java
public class UserController {
  @PostMapping
  public CompletableFuture<String> addUser(@Valid @ModelAttribute("userForm") UserForm form,
                                           BindingResult bindingResult,
                                           Model model) {

    // Form 에러 모델 전달
    if (bindingResult.hasErrors()) {
      return CompletableFuture.completedFuture("users/addUserForm");
    }
    
    RequestUser req = new RequestUser();
    req.setUserId(form.getUserId());
    req.setUserPw(form.getUserPw());
    req.setEmail(form.getEmail());
    req.setUserName(form.getUserName());
    req.setRole("ROLE_USER"); // 기본적으로 일반 롤 부여. 이것 이외로 ROLE_ADMIN 을 처리할 수 있습니다.

    // 동시성을 위한 별도 스레드 풀 사용.
    // 얘는 block 되지만, Nio 스레드를 쉬게 해주기 위해 별도의 스레드를 사용하게 됩니다.
    return CompletableFuture.supplyAsync(() -> {
      Flux<AddUserResponse> res = webClient.mutate()
              .build()
              .post()
              .uri("http://127.0.0.1:8000/user")
              .bodyValue(req)
              .retrieve()
              .onStatus(
                      HttpStatus::is4xxClientError,
                      r -> r.bodyToMono(ErrorResponse.class).map(CustomThrowableException::new))
              .onStatus(
                      HttpStatus::is5xxServerError,
                      r -> r.bodyToMono(ErrorResponse.class).map(CustomThrowableException::new))
              .bodyToFlux(AddUserResponse.class);

      // Mutex Lock 을 위한 객체
      final Object lock = new Object();

      // 백엔드에서 onComplete 이벤트 수신 시, lock 풀기
      res.doOnComplete(() -> {
        synchronized (lock) {
          lock.notify();
        }
      }).subscribe(response -> {
          // 서비스 별 결과 전송
        template.convertAndSend("/sub/user/" + req.getUserId(), response); 
      });

      // Mutex Lock
      synchronized (lock) {
        try {
          lock.wait();
        } catch (InterruptedException e) {
        }
      }
      
      // 로그인 페이지로 자동 리다이렉트
      return "redirect:/";
    }).exceptionally((e) -> {
      bindingResult.rejectValue("userId", null, e.getMessage());
      return "users/addUserForm";
    });
  }
}
```


## 1.2 BE 수정
### 1.2.1 이벤트 수정

회원가입을 하면 인증서버로 API가 전송됩니다. 이 때 인증서버는 채팅/고객 서버에 유저를 만들어주는 이벤트를 발행합니다. 이 이벤트를 수정하려고합니다.

* 기존 이벤트

> * 채팅/고객 서버 중 하나라도 유저가 존재한다면, 인증서버에서 Rollback 이벤트를 전송하여 채팅/고객 서버의 유저를 **삭제**합니다.
> * 인증서버에 유저가 존재하면, 채팅/고객서버에 유저를 추가하지 않습니다. 

* 수정된 이벤트

> * 인증서버는 채팅/고객서버에 유저를 **자동으로 동기화**합니다.
>   1. 인증서버에 유저 저장 및 유지
>   2. 채팅/고객서버에 유저 추가 이벤트 전송(발신 토픽 : `user.newUser.req`, 수신 토픽 : `user.newUser.res`)
>   3. 채팅/고객서버는 유저를 저장 및 유지하고, 중복유저 유무를 이벤트로 보냅니다(발신 토픽 : `user.newUser.res`)

### 1.2.2 SSE 수정
* 유저저장 API 처리 시, 맨 초기에 대기상태로 저장 된 부분또한 WebFlux 통해 SSE 로 전송합니다.
* 성능향상을 위한 `.log()` 제거

